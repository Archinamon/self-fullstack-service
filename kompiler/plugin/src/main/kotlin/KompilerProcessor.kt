package me.archinamon.tcp.server.plugin

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.TypeSpec
import de.jensklingenberg.mpapt.common.methods
import de.jensklingenberg.mpapt.model.AbstractProcessor
import de.jensklingenberg.mpapt.model.Element
import de.jensklingenberg.mpapt.model.RoundEnvironment
import de.jensklingenberg.mpapt.utils.KotlinPlatformValues
import me.archinamon.tcp.server.graph.TcpService
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
import java.io.File

class KompilerProcessor(private val generatedRootDir: File) : AbstractProcessor() {

    private companion object {
        const val PACKAGE = "me.archinamon.server.tcp.service"
    }

    private val serviceClass = TcpService::class.qualifiedName!!

    override fun onProcessingStarted() {
        log("Kompiler: starting processor...")
    }

    override fun process(roundEnvironment: RoundEnvironment) {
        roundEnvironment.getElementsAnnotatedWith(serviceClass)
            .filterIsInstance<Element.ClassElement>()
            .forEach { classElem -> constructService(classElem.classDescriptor) }

        log("Kompiler: RoundTrip end")
    }

    override fun isTargetPlatformSupported(platform: TargetPlatform): Boolean {
        return when (val targetName = platform.first().platformName) {
            KotlinPlatformValues.JS -> false
            KotlinPlatformValues.JVM -> false
            KotlinPlatformValues.NATIVE -> true
            else -> {
                log(targetName)
                false
            }
        }
    }

    override fun getSupportedAnnotationTypes() = setOf(serviceClass)

    private fun constructService(descriptor: ClassDescriptor) {
        val className = descriptor.name.asString()
        val classFqn = descriptor.fqNameSafe.asString()

        val classType = ClassName.bestGuess(classFqn)
        val binderServiceType = ClassName.bestGuess("me.archinamon.server.tcp.bind.BinderService")
        val routeCmdType = ClassName.bestGuess("me.archinamon.server.tcp.bind.RouteCommand")
        val socketBinderType = ClassName.bestGuess("me.archinamon.server.tcp.bind.TcpSocketBinder")

        val defaultImports = sequenceOf(
            binderServiceType, routeCmdType, socketBinderType, classType
        )

        val serviceName = ClassName.bestGuess(classFqn + "Impl")
        val expectation = TypeSpec.objectBuilder(serviceName)
            .addModifiers(KModifier.EXPECT)
            .addSuperinterface(binderServiceType)
            .addSuperinterface(classType)
            .build()

        val manager = TypeSpec.objectBuilder(ClassName.bestGuess(classFqn + "Binder"))
            .superclass(socketBinderType.parameterizedBy(serviceName))
            .addSuperclassConstructorParameter("%T::class", serviceName)
            .addInitializerBlock(CodeBlock.builder()
                .apply {
                    descriptor.methods().forEach { method ->
                        val methodName = method.name
                        add("bind(%T(\"$methodName\"), %T::$methodName)\n", routeCmdType, classType)
                    }
                }
                .build()
            )
            .build()

        File(generatedRootDir, "common")
            .writeFile(className, defaultImports, expectation, manager)

        //fixme: stub frontend code
        File(generatedRootDir, "js")
            .writeFile(className, defaultImports, TypeSpec.objectBuilder(serviceName)
                .addModifiers(KModifier.ACTUAL)
                .superclass(binderServiceType)
                .addSuperinterface(classType)
                .build()
            )
    }

    private fun File.writeFile(
        fileName: String,
        fqnImports: Sequence<ClassName>,
        vararg types: TypeSpec
    ) = FileSpec.builder(PACKAGE, fileName)
        .addComment("Generated by kompiler/plugin module!\n\nDo not edit it manually!")
        .indent("    ")
        .apply {
            fqnImports.forEach { className ->
                addImport(className.packageName, className.simpleName)
            }

            types.forEach(this@apply::addType)
        }
        .build()
        .writeTo(this)
}